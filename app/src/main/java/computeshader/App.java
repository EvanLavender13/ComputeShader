/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package computeshader;

import static java.lang.Math.pow;
import static java.lang.Math.toRadians;
import static org.lwjgl.glfw.GLFW.GLFW_CONTEXT_VERSION_MAJOR;
import static org.lwjgl.glfw.GLFW.GLFW_CONTEXT_VERSION_MINOR;
import static org.lwjgl.glfw.GLFW.GLFW_FALSE;
import static org.lwjgl.glfw.GLFW.GLFW_KEY_ESCAPE;
import static org.lwjgl.glfw.GLFW.GLFW_OPENGL_CORE_PROFILE;
import static org.lwjgl.glfw.GLFW.GLFW_OPENGL_FORWARD_COMPAT;
import static org.lwjgl.glfw.GLFW.GLFW_OPENGL_PROFILE;
import static org.lwjgl.glfw.GLFW.GLFW_RELEASE;
import static org.lwjgl.glfw.GLFW.GLFW_RESIZABLE;
import static org.lwjgl.glfw.GLFW.GLFW_TRUE;
import static org.lwjgl.glfw.GLFW.GLFW_VISIBLE;
import static org.lwjgl.glfw.GLFW.glfwGetTime;
import static org.lwjgl.glfw.GLFW.glfwSetKeyCallback;
import static org.lwjgl.glfw.GLFW.glfwSetWindowShouldClose;
import static org.lwjgl.glfw.GLFW.glfwWindowHint;
import static org.lwjgl.opengl.GL11.GL_GREATER;
import static org.lwjgl.opengl.GL11.GL_ONE_MINUS_SRC_ALPHA;
import static org.lwjgl.opengl.GL11.GL_SRC_ALPHA;
import static org.lwjgl.opengl.GL11.GL_TEXTURE_2D;
import static org.lwjgl.opengl.GL11.glAlphaFunc;
import static org.lwjgl.opengl.GL11.glBindTexture;
import static org.lwjgl.opengl.GL11.glEnable;
import static org.lwjgl.opengl.GL11.glGenTextures;
import static org.lwjgl.opengl.GL11C.GL_BLEND;
import static org.lwjgl.opengl.GL11C.GL_NEAREST;
import static org.lwjgl.opengl.GL11C.GL_TEXTURE_MAG_FILTER;
import static org.lwjgl.opengl.GL11C.GL_TEXTURE_MIN_FILTER;
import static org.lwjgl.opengl.GL11C.GL_TRIANGLES;
import static org.lwjgl.opengl.GL11C.glBlendFunc;
import static org.lwjgl.opengl.GL11C.glDrawArrays;
import static org.lwjgl.opengl.GL15C.GL_DYNAMIC_COPY;
import static org.lwjgl.opengl.GL15C.GL_READ_WRITE;
import static org.lwjgl.opengl.GL15C.glBindBuffer;
import static org.lwjgl.opengl.GL15C.glBufferData;
import static org.lwjgl.opengl.GL15C.glBufferSubData;
import static org.lwjgl.opengl.GL15C.glGenBuffers;
import static org.lwjgl.opengl.GL20C.GL_COMPILE_STATUS;
import static org.lwjgl.opengl.GL20C.GL_FRAGMENT_SHADER;
import static org.lwjgl.opengl.GL20C.GL_VERTEX_SHADER;
import static org.lwjgl.opengl.GL20C.glAttachShader;
import static org.lwjgl.opengl.GL20C.glCompileShader;
import static org.lwjgl.opengl.GL20C.glCreateProgram;
import static org.lwjgl.opengl.GL20C.glCreateShader;
import static org.lwjgl.opengl.GL20C.glGetProgramiv;
import static org.lwjgl.opengl.GL20C.glGetShaderInfoLog;
import static org.lwjgl.opengl.GL20C.glGetShaderi;
import static org.lwjgl.opengl.GL20C.glGetUniformLocation;
import static org.lwjgl.opengl.GL20C.glGetUniformiv;
import static org.lwjgl.opengl.GL20C.glLinkProgram;
import static org.lwjgl.opengl.GL20C.glShaderSource;
import static org.lwjgl.opengl.GL20C.glUniform1f;
import static org.lwjgl.opengl.GL20C.glUseProgram;
import static org.lwjgl.opengl.GL30C.GL_RGBA32F;
import static org.lwjgl.opengl.GL30C.glBindBufferBase;
import static org.lwjgl.opengl.GL30C.glBindFragDataLocation;
import static org.lwjgl.opengl.GL30C.glBindVertexArray;
import static org.lwjgl.opengl.GL30C.glGenVertexArrays;
import static org.lwjgl.opengl.GL30C.glUniform1ui;
import static org.lwjgl.opengl.GL33C.glBindSampler;
import static org.lwjgl.opengl.GL33C.glGenSamplers;
import static org.lwjgl.opengl.GL33C.glSamplerParameteri;
import static org.lwjgl.opengl.GL42C.GL_ALL_BARRIER_BITS;
import static org.lwjgl.opengl.GL42C.glBindImageTexture;
import static org.lwjgl.opengl.GL42C.glMemoryBarrier;
import static org.lwjgl.opengl.GL42C.glTexStorage2D;
import static org.lwjgl.opengl.GL43.GL_SHADER_STORAGE_BLOCK;
import static org.lwjgl.opengl.GL43.glGetProgramResourceIndex;
import static org.lwjgl.opengl.GL43.glShaderStorageBlockBinding;
import static org.lwjgl.opengl.GL43C.GL_COMPUTE_SHADER;
import static org.lwjgl.opengl.GL43C.GL_COMPUTE_WORK_GROUP_SIZE;
import static org.lwjgl.opengl.GL43C.GL_SHADER_STORAGE_BUFFER;
import static org.lwjgl.opengl.GL43C.glCopyImageSubData;
import static org.lwjgl.opengl.GL43C.glDispatchCompute;

import java.io.IOException;
import java.net.URISyntaxException;
import java.nio.IntBuffer;
import java.nio.file.Files;
import java.nio.file.Path;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.lwjgl.BufferUtils;
import org.lwjgl.Version;

import computeshader.slime.AgentUtil;
import imgui.ImGui;
import imgui.app.Application;
import imgui.app.Configuration;

// https://www.lwjgl.org/guide
// https://github.com/LWJGL/lwjgl3-demos/blob/main/src/org/lwjgl/demo/opengl/raytracing/tutorial/Tutorial1.java

public class App extends Application {
    private static final Logger logger = LogManager.getLogger();

    private int width = 1920;
    private int height = 1080;
    private double currentTime = glfwGetTime();
    private double previousFrameTime = 0.0;
    private int fps = 0;
    private int frameCount = 0;

    private int agentMapTexture;
    private int agentMapTextureBinding;
    private int agentMapOutTexture;
    private int agentMapOutTextureBinding;
    private int trailMapTexture;
    private int trailMapTextureBinding;
    private int trailMapOutTexture;
    private int trailMapOutTextureBinding;

    private int frameBufferSampler;
    private int vertexArrayObject;
    private int computeShaderProgram;
    private int computeShaderParametersBuffer;
    private float[] computeShaderParameters;
    private int computeShaderStageUniform;
    private int computeShaderTimeUniform;
    private int displayShaderProgram;

    private int workGroupSizeX;
    private int numAgents;

    private float[] sensingDistanceParameter;
    private float[] sensingAngleParameter;
    private float[] turningAngleParameter;
    private float[] depositAmountParameter;
    private float[] decayAmountParameter;
    private float[] stepSizeParameter;

    @Override
    public void configure(Configuration config) {
        logger.info("Configuring window");
        config.setTitle("Compute Shaders");
        config.setWidth(1600);
        config.setHeight(900);
        // config.setFullScreen(true);

        glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
        glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GLFW_TRUE);
        glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
        glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6);
        glfwWindowHint(GLFW_VISIBLE, GLFW_FALSE);
        glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE);
        this.colorBg.set(0.0f, 0.0f, 0.0f, 1.0f);

        numAgents = (int) pow(2, 23);

        sensingDistanceParameter = new float[1];
        sensingDistanceParameter[0] = 10.0f;

        sensingAngleParameter = new float[1];
        sensingAngleParameter[0] = (float) toRadians(45.0f);

        turningAngleParameter = new float[1];
        turningAngleParameter[0] = (float) toRadians(45.0f);

        depositAmountParameter = new float[1];
        depositAmountParameter[0] = 0.01f;

        decayAmountParameter = new float[1];
        decayAmountParameter[0] = 0.008f;

        stepSizeParameter = new float[1];
        stepSizeParameter[0] = 1.0f;
    }

    @Override
    public void preRun() {
        glfwSetKeyCallback(getHandle(), (window, key, scancode, action, mods) -> {
            if (key == GLFW_KEY_ESCAPE && action == GLFW_RELEASE) {
                glfwSetWindowShouldClose(getHandle(), true); // We will detect this in the rendering loop
            }
        });

        glEnable(GL_BLEND);
        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
        glAlphaFunc(GL_GREATER, 0.1f);

        initFrameBufferTexture();
        initFrameBufferSampler();
        vertexArrayObject = glGenVertexArrays();
        logger.debug("Created vertex array object: {}", vertexArrayObject);
        try {
            initComputeShaderProgram();
            initDisplayShaderProgram();
        } catch (IOException | URISyntaxException e) {
            e.printStackTrace();
        }
    }

    @Override
    public void process() {
        currentTime = glfwGetTime();
        frameCount++;

        double elapsedTime = currentTime - previousFrameTime;

        if (elapsedTime >= 1.0) {
            previousFrameTime = currentTime;
            fps = frameCount;
            frameCount = 0;
        }

        ImGui.text("FPS:   : " + fps);
        ImGui.text("Runtime: " + currentTime);
        ImGui.text("Particle Count: " + numAgents);

        if (ImGui.sliderFloat("Sensing Distance", sensingDistanceParameter, 0.0f, 256.0f)) {
            sensingDistanceParameter[0] = (float) Math.floor(sensingDistanceParameter[0]);
            glBindBuffer(GL_SHADER_STORAGE_BUFFER, computeShaderParametersBuffer);
            glBufferSubData(GL_SHADER_STORAGE_BUFFER, 2 * Float.BYTES, sensingDistanceParameter);
            glBindBuffer(GL_SHADER_STORAGE_BUFFER, 0);
        }

        if (ImGui.sliderAngle("Sensing Angle", sensingAngleParameter, 0.0f, 180.0f)) {
            glBindBuffer(GL_SHADER_STORAGE_BUFFER, computeShaderParametersBuffer);
            glBufferSubData(GL_SHADER_STORAGE_BUFFER, 3 * Float.BYTES, sensingAngleParameter);
            glBindBuffer(GL_SHADER_STORAGE_BUFFER, 0);
        }

        if (ImGui.sliderAngle("Turning Angle", turningAngleParameter, 0.0f, 360.0f)) {
            glBindBuffer(GL_SHADER_STORAGE_BUFFER, computeShaderParametersBuffer);
            glBufferSubData(GL_SHADER_STORAGE_BUFFER, 4 * Float.BYTES, turningAngleParameter);
            glBindBuffer(GL_SHADER_STORAGE_BUFFER, 0);
        }

        if (ImGui.sliderFloat("Deposit Amount", depositAmountParameter, 0.01f, 1.0f)) {
            glBindBuffer(GL_SHADER_STORAGE_BUFFER, computeShaderParametersBuffer);
            glBufferSubData(GL_SHADER_STORAGE_BUFFER, 5 * Float.BYTES, depositAmountParameter);
            glBindBuffer(GL_SHADER_STORAGE_BUFFER, 0);
        }

        if (ImGui.sliderFloat("Decay Amount", decayAmountParameter, 0.0f, 1.0f)) {
            glBindBuffer(GL_SHADER_STORAGE_BUFFER, computeShaderParametersBuffer);
            glBufferSubData(GL_SHADER_STORAGE_BUFFER, 6 * Float.BYTES, decayAmountParameter);
            glBindBuffer(GL_SHADER_STORAGE_BUFFER, 0);
        }

        if (ImGui.sliderFloat("Step Size", stepSizeParameter, 0.0f, 100.0f)) {
            stepSizeParameter[0] = (float) Math.floor(stepSizeParameter[0]);
            glBindBuffer(GL_SHADER_STORAGE_BUFFER, computeShaderParametersBuffer);
            glBufferSubData(GL_SHADER_STORAGE_BUFFER, 7 * Float.BYTES, stepSizeParameter);
            glBindBuffer(GL_SHADER_STORAGE_BUFFER, 0);
        }    

        doCompute();
    }

    public void doCompute() {
        glUseProgram(computeShaderProgram);
        {
            glBindImageTexture(agentMapTextureBinding, agentMapTexture, 0, false, 0, GL_READ_WRITE, GL_RGBA32F);
            glBindImageTexture(agentMapOutTextureBinding, agentMapOutTexture, 0, false, 0, GL_READ_WRITE, GL_RGBA32F);
            glBindImageTexture(trailMapTextureBinding, trailMapTexture, 0, false, 0, GL_READ_WRITE, GL_RGBA32F);
            glBindImageTexture(trailMapOutTextureBinding, trailMapOutTexture, 0, false, 0, GL_READ_WRITE, GL_RGBA32F);

            glMemoryBarrier(GL_ALL_BARRIER_BITS);
            glUniform1ui(computeShaderStageUniform, 0);
            glUniform1f(computeShaderTimeUniform, (float) currentTime);
            glUniform1ui(0, GL_SHADER_STORAGE_BUFFER);
            glDispatchCompute(numAgents / workGroupSizeX, 1, 1);
            glMemoryBarrier(GL_ALL_BARRIER_BITS);

            glCopyImageSubData(trailMapOutTexture, GL_TEXTURE_2D, 0, 0, 0, 0,
                    trailMapTexture, GL_TEXTURE_2D, 0, 0, 0, 0,
                    width, height, 1);

            glCopyImageSubData(agentMapOutTexture, GL_TEXTURE_2D, 0, 0, 0, 0,
                    agentMapTexture, GL_TEXTURE_2D, 0, 0, 0, 0,
                    width, height, 1);

            glMemoryBarrier(GL_ALL_BARRIER_BITS);
            glUniform1ui(computeShaderStageUniform, 1);
            glDispatchCompute((width * height) / workGroupSizeX, 1, 1);
            glMemoryBarrier(GL_ALL_BARRIER_BITS);

            glCopyImageSubData(trailMapOutTexture, GL_TEXTURE_2D, 0, 0, 0, 0,
                    trailMapTexture, GL_TEXTURE_2D, 0, 0, 0, 0,
                    width, height, 1);

            glBindImageTexture(agentMapTextureBinding, 0, 0, false, 0, 0, 0);
            glBindImageTexture(agentMapOutTextureBinding, 0, 0, false, 0, 0, 0);
            glBindImageTexture(trailMapTextureBinding, 0, 0, false, 0, 0, 0);
            glBindImageTexture(trailMapOutTextureBinding, 0, 0, false, 0, 0, 0);
        }
        glUseProgram(0);

        // swapFrameBufferTextures();

        glUseProgram(displayShaderProgram);
        {
            glBindVertexArray(vertexArrayObject);
            glBindTexture(GL_TEXTURE_2D, trailMapTexture);
            glBindSampler(0, frameBufferSampler);
            glDrawArrays(GL_TRIANGLES, 0, 3);
            glBindSampler(0, 0);
            glBindTexture(GL_TEXTURE_2D, 0);
            glBindVertexArray(0);
        }
        glUseProgram(0);
    }

    private void initFrameBufferTexture() {
        agentMapTexture = glGenTextures();
        agentMapOutTexture = glGenTextures();
        trailMapTexture = glGenTextures();
        trailMapOutTexture = glGenTextures();

        glBindTexture(GL_TEXTURE_2D, agentMapTexture);
        glTexStorage2D(GL_TEXTURE_2D, 1, GL_RGBA32F, width, height);
        glBindTexture(GL_TEXTURE_2D, 0);

        glBindTexture(GL_TEXTURE_2D, agentMapOutTexture);
        glTexStorage2D(GL_TEXTURE_2D, 1, GL_RGBA32F, width, height);
        glBindTexture(GL_TEXTURE_2D, 0);

        glBindTexture(GL_TEXTURE_2D, trailMapTexture);
        glTexStorage2D(GL_TEXTURE_2D, 1, GL_RGBA32F, width, height);
        glBindTexture(GL_TEXTURE_2D, 0);

        glBindTexture(GL_TEXTURE_2D, trailMapOutTexture);
        glTexStorage2D(GL_TEXTURE_2D, 1, GL_RGBA32F, width, height);
        glBindTexture(GL_TEXTURE_2D, 0);
    }

    // private void swapFrameBufferTextures() {
    // int temp = currentFrameBufferTexture;
    // currentFrameBufferTexture = nextFrameBufferTexture;
    // nextFrameBufferTexture = temp;
    // }

    private void initFrameBufferSampler() {
        frameBufferSampler = glGenSamplers();
        logger.debug("Created frame buffer sampler: {}", frameBufferSampler);

        glSamplerParameteri(frameBufferSampler, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
        glSamplerParameteri(frameBufferSampler, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    }

    private void initComputeShaderProgram() throws IOException, URISyntaxException {
        computeShaderProgram = glCreateProgram();
        logger.debug("Created compute shader program: {}", computeShaderProgram);

        int computeShaderId = glCreateShader(GL_COMPUTE_SHADER);
        logger.debug("Created compute shader: {}", computeShaderId);

        String computeShaderSource = Files.readString(Path.of(getClass().getResource("/compute.glsl").toURI()));
        // logger.debug("Shader 'compute.glsl' source:\n{}", computeShaderSource);

        glShaderSource(computeShaderId, computeShaderSource);
        glCompileShader(computeShaderId);

        if (glGetShaderi(computeShaderId, GL_COMPILE_STATUS) == 0) {
            throw new IOException("Error compiling Shader code: " + glGetShaderInfoLog(computeShaderId, 1024));
        }

        glAttachShader(computeShaderProgram, computeShaderId);
        glLinkProgram(computeShaderProgram);

        initComputeShaderParameters();

        glUseProgram(computeShaderProgram);
        {
            IntBuffer workGroupSize = BufferUtils.createIntBuffer(3);
            glGetProgramiv(computeShaderProgram, GL_COMPUTE_WORK_GROUP_SIZE, workGroupSize);
            workGroupSizeX = workGroupSize.get(0);
            int workGroupSizeY = workGroupSize.get(1);
            int workGroupSizeZ = workGroupSize.get(2);
            logger.debug("Work group size: [x {}, y {}, z {}]", workGroupSizeX, workGroupSizeY, workGroupSizeZ);

            IntBuffer parameters = BufferUtils.createIntBuffer(4);
            glGetUniformiv(computeShaderProgram, glGetUniformLocation(computeShaderProgram, "AgentMap"), parameters);
            agentMapTextureBinding = parameters.get();
            glGetUniformiv(computeShaderProgram, glGetUniformLocation(computeShaderProgram, "AgentMapOut"), parameters);
            agentMapOutTextureBinding = parameters.get();
            glGetUniformiv(computeShaderProgram, glGetUniformLocation(computeShaderProgram, "TrailMap"), parameters);
            trailMapTextureBinding = parameters.get();
            glGetUniformiv(computeShaderProgram, glGetUniformLocation(computeShaderProgram, "TrailMapOut"), parameters);
            trailMapOutTextureBinding = parameters.get();

            computeShaderStageUniform = glGetUniformLocation(computeShaderProgram, "Stage");
            logger.debug("Stage uniform location: {}", computeShaderStageUniform);
            computeShaderTimeUniform = glGetUniformLocation(computeShaderProgram, "Time");
            logger.debug("Time uniform location: {}", computeShaderTimeUniform);
        }
        glUseProgram(0);
    }

    private void initComputeShaderParameters() {
        computeShaderParametersBuffer = glGenBuffers();
        glBindBuffer(GL_SHADER_STORAGE_BUFFER, computeShaderParametersBuffer);

        computeShaderParameters = new float[] {
                (float) width,
                (float) height,
                sensingDistanceParameter[0],
                sensingAngleParameter[0],
                turningAngleParameter[0],
                depositAmountParameter[0],
                decayAmountParameter[0],
                stepSizeParameter[0]
        };

        glBufferData(GL_SHADER_STORAGE_BUFFER, computeShaderParameters, GL_DYNAMIC_COPY);
        glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 4, computeShaderParametersBuffer);
        glBindBuffer(GL_SHADER_STORAGE_BUFFER, 0);

        int computeShaderAgentsBuffer = glGenBuffers();
        glBindBuffer(GL_SHADER_STORAGE_BUFFER, computeShaderAgentsBuffer);

        logger.info("Creating {} agents", numAgents);
        float[] computeShaderAgents = AgentUtil.nAgentsHueGradient(numAgents, width, height);

        int bufferLocation = glGetProgramResourceIndex(computeShaderProgram, GL_SHADER_STORAGE_BLOCK, "Agents");
        glShaderStorageBlockBinding(computeShaderProgram, bufferLocation, bufferLocation);

        glBufferData(GL_SHADER_STORAGE_BUFFER, computeShaderAgents, GL_DYNAMIC_COPY);
        glBindBufferBase(GL_SHADER_STORAGE_BUFFER, bufferLocation, computeShaderAgentsBuffer);
        glBindBuffer(GL_SHADER_STORAGE_BUFFER, 0);
    }

    private void initDisplayShaderProgram() throws IOException, URISyntaxException {
        displayShaderProgram = glCreateProgram();
        logger.debug("Created display shader program: {}", displayShaderProgram);

        int displayVertShaderId = initDisplayVertShader();
        int displayFragShaderId = initDisplayFragShader();
        glAttachShader(displayShaderProgram, displayVertShaderId);
        glAttachShader(displayShaderProgram, displayFragShaderId);
        glBindFragDataLocation(displayShaderProgram, 0, "color");
        glLinkProgram(displayShaderProgram);
    }

    private int initDisplayVertShader() throws IOException, URISyntaxException {
        int displayVertShaderId = glCreateShader(GL_VERTEX_SHADER);
        logger.debug("Created display vertex shader: {}", displayVertShaderId);

        String displayVertShaderSource = Files
                .readString(Path.of(getClass().getResource("/display.vert.glsl").toURI()));
        // logger.debug("Shader 'display.vert.glsl' source:\n{}",
        // displayVertShaderSource);

        glShaderSource(displayVertShaderId, displayVertShaderSource);
        glCompileShader(displayVertShaderId);

        if (glGetShaderi(displayVertShaderId, GL_COMPILE_STATUS) == 0) {
            throw new IOException("Error compiling Shader code: " + glGetShaderInfoLog(displayVertShaderId, 1024));
        }

        return displayVertShaderId;
    }

    private int initDisplayFragShader() throws IOException, URISyntaxException {
        int displayFragShaderId = glCreateShader(GL_FRAGMENT_SHADER);
        logger.debug("Created display fragment shader: {}", displayFragShaderId);

        String displayFragShaderSource = Files
                .readString(Path.of(getClass().getResource("/display.frag.glsl").toURI()));
        // logger.debug("Shader 'display.frag.glsl' source:\n{}",
        // displayFragShaderSource);

        glShaderSource(displayFragShaderId, displayFragShaderSource);
        glCompileShader(displayFragShaderId);

        if (glGetShaderi(displayFragShaderId, GL_COMPILE_STATUS) == 0) {
            throw new IOException("Error compiling Shader code: " + glGetShaderInfoLog(displayFragShaderId, 1024));
        }

        return displayFragShaderId;
    }

    public static void main(String[] args) {
        logger.info("LWJGL Version: {}", Version.getVersion());

        launch(new App());
    }
}
